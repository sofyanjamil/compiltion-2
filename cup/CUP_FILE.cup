/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import ast.*;

parser code 
{:
	public Lexer lexer;
	public int errorLine = -1;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	
	public void report_error(String message, Object info)
	{
		if (errorLine < 0) {
			errorLine = lexer.getLine();
		}
	}
	
	public void syntax_error(Symbol cur_token)
	{
		if (errorLine < 0 && cur_token != null) {
			// cur_token.left is 0-indexed line number from lexer
			errorLine = cur_token.left + 1;
		} else if (errorLine < 0) {
			errorLine = lexer.getLine();
		}
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	return s; 
:};

/*************/
/* TERMINALS */
/*************/
terminal IF;
terminal ELSE;
terminal WHILE;
terminal RETURN;
terminal NEW;
terminal CLASS;
terminal EXTENDS;
terminal ARRAY;
terminal NIL;

terminal TYPE_INT;
terminal TYPE_STRING;
terminal TYPE_VOID;

terminal EQ;
terminal LT;
terminal GT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal ASSIGN;

terminal DOT;
terminal COMMA;
terminal SEMICOLON;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;

terminal Integer INT;
terminal String ID;
terminal String STRING;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AST_PROGRAM program;
non terminal AST_DEC_LIST decList;
non terminal AST_DEC dec;
non terminal AST_TYPE type;
non terminal AST_VAR_DEC varDec;
non terminal AST_FUNC_DEC funcDec;
non terminal AST_CLASS_DEC classDec;
non terminal AST_ARRAY_TYPEDEF arrayTypedef;
non terminal AST_CFIELD_LIST cFieldList;
non terminal AST_CFIELD cField;
non terminal AST_STMT_LIST stmtList;
non terminal AST_STMT stmt;
non terminal AST_EXP exp;
non terminal AST_NEW_EXP newExp;
non terminal AST_VAR var;
non terminal AST_EXP_LIST expList;
non terminal AST_EXP_LIST expListOpt;
non terminal AST_ARG_LIST argList;
non terminal AST_ARG_LIST argListOpt;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
/* From Table 1: 1 = lowest, 8 = highest */
/* CUP: declarations listed first have lower precedence */
precedence nonassoc ASSIGN;       /* 1: :=   (lowest)  */
precedence left EQ;               /* 2: =    left      */
precedence left LT, GT;           /* 3: <,>  left      */
precedence left PLUS, MINUS;      /* 4: +,-  left      */
precedence left TIMES, DIVIDE;    /* 5: *,/  left      */
precedence left LBRACK;           /* 6: []   array     */
precedence left LPAREN;           /* 7: ()   call      */
precedence left DOT;              /* 8: .    (highest) */

/************************/
/* START WITH: program  */
/************************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/

/****************************/
/* program ::= dec { dec }  */
/****************************/
program ::= decList:dl
			{: RESULT = new AST_PROGRAM(dl); :}
			;

decList ::= dec:d decList:dl
			{: RESULT = new AST_DEC_LIST(d, dl); :}
			| dec:d
			{: RESULT = new AST_DEC_LIST(d, null); :}
			;

/*************************************************/
/* dec ::= varDec | funcDec | classDec | arrayTypedef */
/*************************************************/
dec ::= varDec:v
		{: RESULT = v; :}
		| funcDec:f
		{: RESULT = f; :}
		| classDec:c
		{: RESULT = c; :}
		| arrayTypedef:a
		{: RESULT = a; :}
		;

/*************************************************/
/* type ::= TYPE_INT | TYPE_STRING | TYPE_VOID | ID */
/*************************************************/
type ::= TYPE_INT:t
		{: RESULT = new AST_TYPE(tleft+1, "int"); :}
		| TYPE_STRING:t
		{: RESULT = new AST_TYPE(tleft+1, "string"); :}
		| TYPE_VOID:t
		{: RESULT = new AST_TYPE(tleft+1, "void"); :}
		| ID:name
		{: RESULT = new AST_TYPE(nameleft+1, name); :}
		;

/*********************************************************/
/* varDec ::= type ID [ ASSIGN exp ] SEMICOLON           */
/*          | type ID ASSIGN newExp SEMICOLON            */
/*********************************************************/
varDec ::= type:t ID:name SEMICOLON
			{: RESULT = new AST_VAR_DEC(tleft+1, t, name, null, null); :}
			| type:t ID:name ASSIGN exp:e SEMICOLON
			{: RESULT = new AST_VAR_DEC(tleft+1, t, name, e, null); :}
			| type:t ID:name ASSIGN newExp:ne SEMICOLON
			{: RESULT = new AST_VAR_DEC(tleft+1, t, name, null, ne); :}
			;

/*******************************************************************/
/* funcDec ::= type ID LPAREN [type ID {COMMA type ID}] RPAREN     */
/*             LBRACE stmtList RBRACE                               */
/*******************************************************************/
funcDec ::= type:t ID:name LPAREN argListOpt:args RPAREN LBRACE stmtList:body RBRACE
			{: RESULT = new AST_FUNC_DEC(tleft+1, t, name, args, body); :}
			;

argListOpt ::= argList:al
			{: RESULT = al; :}
			|
			{: RESULT = null; :}
			;

argList ::= type:t ID:name COMMA argList:al
			{: RESULT = new AST_ARG_LIST(t, name, al); :}
			| type:t ID:name
			{: RESULT = new AST_ARG_LIST(t, name, null); :}
			;

/*************************************************************/
/* classDec ::= CLASS ID [EXTENDS ID] LBRACE cField+ RBRACE  */
/*************************************************************/
classDec ::= CLASS:c ID:name LBRACE cFieldList:fields RBRACE
			{: RESULT = new AST_CLASS_DEC(cleft+1, name, null, fields); :}
			| CLASS:c ID:name EXTENDS ID:parent LBRACE cFieldList:fields RBRACE
			{: RESULT = new AST_CLASS_DEC(cleft+1, name, parent, fields); :}
			;

cFieldList ::= cField:cf cFieldList:cfl
			{: RESULT = new AST_CFIELD_LIST(cf, cfl); :}
			| cField:cf
			{: RESULT = new AST_CFIELD_LIST(cf, null); :}
			;

/********************************/
/* cField ::= varDec | funcDec  */
/********************************/
cField ::= varDec:v
		{: RESULT = new AST_CFIELD(v); :}
		| funcDec:f
		{: RESULT = new AST_CFIELD(f); :}
		;

/*********************************************************/
/* arrayTypedef ::= ARRAY ID EQ type LBRACK RBRACK SEMICOLON */
/*********************************************************/
arrayTypedef ::= ARRAY:a ID:name EQ type:t LBRACK RBRACK SEMICOLON
			{: RESULT = new AST_ARRAY_TYPEDEF(aleft+1, name, t); :}
			;

/****************************/
/* stmtList ::= stmt { stmt } */
/****************************/
stmtList ::= stmt:s stmtList:sl
			{: RESULT = new AST_STMT_LIST(s, sl); :}
			| stmt:s
			{: RESULT = new AST_STMT_LIST(s, null); :}
			;

/*********************************************************/
/* stmt ::= varDec                                        */
/*        | var ASSIGN exp SEMICOLON                      */
/*        | var ASSIGN newExp SEMICOLON                   */
/*        | RETURN [exp] SEMICOLON                        */
/*        | IF LPAREN exp RPAREN LBRACE stmtList RBRACE   */
/*            [ELSE LBRACE stmtList RBRACE]               */
/*        | WHILE LPAREN exp RPAREN LBRACE stmtList RBRACE */
/*        | callExp SEMICOLON                              */
/*********************************************************/
stmt ::= varDec:v
		{: RESULT = new AST_STMT_VAR_DEC(v); :}
		| var:v ASSIGN exp:e SEMICOLON
		{: RESULT = new AST_STMT_ASSIGN(vleft+1, v, e, null); :}
		| var:v ASSIGN newExp:ne SEMICOLON
		{: RESULT = new AST_STMT_ASSIGN(vleft+1, v, null, ne); :}
		| RETURN:r SEMICOLON
		{: RESULT = new AST_STMT_RETURN(rleft+1, null); :}
		| RETURN:r exp:e SEMICOLON
		{: RESULT = new AST_STMT_RETURN(rleft+1, e); :}
		| IF:i LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE
		{: RESULT = new AST_STMT_IF(ileft+1, cond, body, null); :}
		| IF:i LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE ELSE LBRACE stmtList:elseBody RBRACE
		{: RESULT = new AST_STMT_IF(ileft+1, cond, body, elseBody); :}
		| WHILE:w LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE
		{: RESULT = new AST_STMT_WHILE(wleft+1, cond, body); :}
		| ID:name LPAREN expListOpt:args RPAREN SEMICOLON
		{: RESULT = new AST_STMT_CALL(nameleft+1, null, name, args); :}
		| var:v DOT ID:name LPAREN expListOpt:args RPAREN SEMICOLON
		{: RESULT = new AST_STMT_CALL(vleft+1, v, name, args); :}
		;

/************************************************************/
/* exp ::= var                                               */
/*       | LPAREN exp RPAREN                                 */
/*       | exp (PLUS|MINUS|TIMES|DIVIDE|LT|GT|EQ) exp        */
/*       | callExp                                           */
/*       | [MINUS] INT                                       */
/*       | NIL                                               */
/*       | STRING                                            */
/************************************************************/
exp ::= var:v
		{: RESULT = new AST_EXP_VAR(vleft+1, v); :}
		| LPAREN exp:e RPAREN
		{: RESULT = e; :}
		| exp:e1 PLUS exp:e2
		{: RESULT = new AST_EXP_BINOP(e1left+1, e1, e2, "+"); :}
		| exp:e1 MINUS exp:e2
		{: RESULT = new AST_EXP_BINOP(e1left+1, e1, e2, "-"); :}
		| exp:e1 TIMES exp:e2
		{: RESULT = new AST_EXP_BINOP(e1left+1, e1, e2, "*"); :}
		| exp:e1 DIVIDE exp:e2
		{: RESULT = new AST_EXP_BINOP(e1left+1, e1, e2, "/"); :}
		| exp:e1 LT exp:e2
		{: RESULT = new AST_EXP_BINOP(e1left+1, e1, e2, "<"); :}
		| exp:e1 GT exp:e2
		{: RESULT = new AST_EXP_BINOP(e1left+1, e1, e2, ">"); :}
		| exp:e1 EQ exp:e2
		{: RESULT = new AST_EXP_BINOP(e1left+1, e1, e2, "="); :}
		| INT:i
		{: RESULT = new AST_EXP_INT(ileft+1, i, false); :}
		| MINUS INT:i
		{: RESULT = new AST_EXP_INT(ileft+1, i, true); :}
		| NIL:n
		{: RESULT = new AST_EXP_NIL(nleft+1); :}
		| STRING:s
		{: RESULT = new AST_EXP_STRING(sleft+1, s); :}
		| ID:name LPAREN expListOpt:args RPAREN
		{: RESULT = new AST_EXP_CALL(nameleft+1, null, name, args); :}
		| var:v DOT ID:name LPAREN expListOpt:args RPAREN
		{: RESULT = new AST_EXP_CALL(vleft+1, v, name, args); :}
		;

expListOpt ::= expList:el
			{: RESULT = el; :}
			|
			{: RESULT = null; :}
			;

expList ::= exp:e COMMA expList:el
			{: RESULT = new AST_EXP_LIST(e, el); :}
			| exp:e
			{: RESULT = new AST_EXP_LIST(e, null); :}
			;

/*********************************************/
/* newExp ::= NEW type                        */
/*          | NEW type LBRACK exp RBRACK     */
/*********************************************/
newExp ::= NEW:n type:t
		{: RESULT = new AST_NEW_EXP(nleft+1, t, null); :}
		| NEW:n type:t LBRACK exp:e RBRACK
		{: RESULT = new AST_NEW_EXP(nleft+1, t, e); :}
		;

/**************************************/
/* var ::= ID                          */
/*       | var DOT ID                  */
/*       | var LBRACK exp RBRACK       */
/**************************************/
var ::= ID:name
		{: RESULT = new AST_VAR_SIMPLE(nameleft+1, name); :}
		| var:v DOT ID:field
		{: RESULT = new AST_VAR_FIELD(vleft+1, v, field); :}
		| var:v LBRACK exp:e RBRACK
		{: RESULT = new AST_VAR_SUBSCRIPT(vleft+1, v, e); :}
		;
